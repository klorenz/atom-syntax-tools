// Generated by CoffeeScript 1.9.1
"$ curl https://raw.githubusercontent.com/twilson63/cakefile-template/master/Cakefile > ../Cakefile\n\n$ cd .. && coffee -c -o lib src/main.coffee\n$ cd .. && npm version minor\n$ cd .. && git comm\n$ cd .. && cake build";
var Grammar, GrammarCreator, createGrammar, makeGrammar;

GrammarCreator = (function() {
  function GrammarCreator(grammar1, print1) {
    this.grammar = grammar1;
    this.print = print1 != null ? print1 : false;
  }

  GrammarCreator.prototype.process = function() {
    var CSON, G, all_done, fs, grammar, i, k, len, macros, n, name, pats, print, ref, ref1, ref2, v;
    grammar = this.grammar;
    print = this.print;
    G = {};
    ref = ["comment", "fileTypes", "firstLineMatch", "keyEquivalent", "name", "scopeName", "injectionSelector"];
    for (i = 0, len = ref.length; i < len; i++) {
      n = ref[i];
      if (grammar[n] != null) {
        G[n] = grammar[n];
      }
    }
    this.autoAppendScopeName = grammar.autoAppendScopeName, this.macros = grammar.macros;
    if (typeof this.autoAppendScopeName === "undefined") {
      this.autoAppendScopeName = true;
    }
    if (typeof this.macros === "undefined") {
      this.macros = {};
    }
    this.grammarScopeName = G.scopeName.replace(/.*\./, '');
    this.hasGrammarScopeName = new RegExp("\\." + this.grammarScopeName + "$");
    macros = this.macros;
    for (k in macros) {
      v = macros[k];
      if (v instanceof RegExp) {
        macros[k] = v.source;
      }
    }
    for (k in macros) {
      v = macros[k];
      macros[k] = this.resolveMacros(v);
    }
    while (true) {
      all_done = true;
      for (k in macros) {
        v = macros[k];
        macros[k] = this.resolveMacros(v);
        if (/\{[a-zA-Z_]\w*\}/.test(macros[k])) {
          all_done = false;
          if (v === macros[k]) {
            throw "unresolved macro in " + v;
          }
        }
      }
      if (all_done) {
        break;
      }
    }
    name = grammar['name'];
    ref1 = this.makePattern(grammar);
    for (k in ref1) {
      v = ref1[k];
      G[k] = v;
    }
    G['name'] = name;
    if (grammar.repository != null) {
      G.repository = {};
      ref2 = grammar.repository;
      for (k in ref2) {
        v = ref2[k];
        pats = this.makePattern(v, macros);
        if ((pats.begin != null) || (pats.match != null)) {
          pats = {
            "patterns": [pats]
          };
        } else if (pats instanceof Array) {
          pats = {
            "patterns": pats
          };
        }
        G.repository[k] = pats;
      }
    }
    if (print) {
      if (print.match(/\.cson$/)) {
        CSON = require("season");
        fs = require("fs");
        fs.writeFileSync(print, CSON.stringify(G));
      } else if (print.match(/\.json$/)) {
        fs.writeFileSync(print, JSON.stringify(G, null, "    "));
      } else if (print === "CSON") {
        CSON = require("season");
        process.stdout.write(CSON.stringify(G));
      } else {
        process.stdout.write(JSON.stringify(G, null, "    "));
      }
    }
    return G;
  };

  GrammarCreator.prototype.resolveMacros = function(regex) {
    var macros;
    if (regex instanceof RegExp) {
      regex = regex.source;
    }
    macros = this.macros;
    return regex.replace(/\{\w+\}/g, function(mob) {
      var s;
      s = mob.slice(1, -1);
      if (typeof macros[s] !== "undefined") {
        return macros[s];
      } else {
        return mob;
      }
    });
  };

  GrammarCreator.prototype.makeScopeName = function(name) {
    name = this.resolveMacros(name);
    if (this.autoAppendScopeName) {
      if (!this.hasGrammarScopeName.test(name)) {
        return name + "." + this.grammarScopeName;
      }
    }
    return name;
  };

  GrammarCreator.prototype.makePattern = function(pattern) {
    var P, c, ck, cv, k, p, pat, v;
    pat = pattern;
    P = {};
    if (typeof pattern === "string") {
      P.include = pattern;
      return P;
    }
    if (pattern instanceof Array) {
      return (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = pattern.length; i < len; i++) {
          p = pattern[i];
          results.push(this.makePattern(p));
        }
        return results;
      }).call(this);
    }
    for (k in pat) {
      v = pat[k];
      switch (k) {
        case "N":
        case "contentName":
          P.contentName = this.makeScopeName(v);
          break;
        case "i":
        case "include":
          P.include = v;
          break;
        case "n":
        case "name":
          P.name = this.makeScopeName(v);
          break;
        case "m":
        case "match":
          P.match = this.resolveMacros(v);
          break;
        case "b":
        case "begin":
          P.begin = this.resolveMacros(v);
          break;
        case "e":
        case "end":
          P.end = this.resolveMacros(v);
          break;
        case "c":
        case "captures":
        case "beginCaptures":
          if (P.begin != null) {
            P.beginCaptures = c = {};
          } else {
            P.captures = c = {};
          }
          if (typeof v === "string") {
            c[0] = {
              name: this.makeScopeName(v)
            };
          } else {
            for (ck in v) {
              cv = v[ck];
              if (typeof cv !== "string") {
                c[ck] = this.makePattern(cv);
              } else {
                c[ck] = {
                  name: this.makeScopeName(cv)
                };
              }
            }
          }
          break;
        case "C":
        case "endCaptures":
          P.endCaptures = c = {};
          if (typeof v === "string") {
            c[0] = {
              name: this.makeScopeName(v)
            };
          } else {
            for (ck in v) {
              cv = v[ck];
              if (typeof cv !== "string") {
                c[ck] = this.makePattern(cv);
              } else {
                c[ck] = {
                  name: this.makeScopeName(cv)
                };
              }
            }
          }
          break;
        case "p":
        case "patterns":
          if (!(v instanceof Array)) {
            v = [v];
          }
          P.patterns = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = v.length; i < len; i++) {
              p = v[i];
              results.push(this.makePattern(p));
            }
            return results;
          }).call(this);
          break;
        case "L":
        case "applyEndPatternLast":
          P.applyEndPatternLast = v;
          break;
        default:
          P[k] = v;
      }
    }
    return P;
  };

  return GrammarCreator;

})();

makeGrammar = function(grammar, print) {
  if (print == null) {
    print = false;
  }
  return (new GrammarCreator(grammar, print)).process();
};

Grammar = require('first-mate').Grammar;

createGrammar = function(grammar) {
  return new Grammar(atom.grammars, makeGrammar(grammar));
};

module.exports = {
  makeGrammar: makeGrammar,
  createGrammar: createGrammar
};
